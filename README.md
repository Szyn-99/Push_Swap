*This project has been created as part of the 42 curriculum by aymel-ha.*

## Description

This​‍​‌‍​‍‌ project is a stage of 42 school curriculum. Its main purpose is to increase the understanding of fundamental programming concepts by implementing them in practice. The project's task is to create and make a program that follows the set of very strict rules and highly focused on algorithmic thinking, memory management, and code structure. The big focus is on performance, correctness, and meeting the project requirements. This project is developed as per the 42 Norm and does not use external libraries except when explicitly ​‍​‌‍​‍‌allowed.


## Instructions
To obtain the executable binary and compile the project, run:
push_swap -> execute the following command in the root of the repository
↳ make
To obtain: 
checker -> execute the following command in the root of the repository
↳ make bonus

Other operations can be used by adding the following "flags":
↳ make re: rebuild the project
↳ make clean: deleting the object files after using them to compile the project 
↳ make fclean: deleting the object files and the executable 

### Resources
many resources were used to accomplish and finish this project, some of the resources were :

⧪ to get a sight about complexity and analyses https://en.wikipedia.org/wiki/Analysis_of_algorithms
⧪ analysing the approach of other peers on the project and algorithms : 
        https://medium.com/@ayogun/push-swap-c1f5d2d41e97
        https://satyadeepmaheshwari.medium.com/sorting-large-datasets-with-limited-memory-the-chunked-merge-sort-approach-318275275c81
        https://stackoverflow.com/questions/45631661/better-sort-algorithm-for-pre-sorted-chunks
        https://medium.com/@julien-ctx/push-swap-an-easy-and-efficient-algorithm-to-sort-numbers-4b7049c2639a
⧪ Visualizing the process of sorting was helpful to decide which move to include in the algorithm I choose, for example, this website was helpful:
        https://nmannage.github.io/showcase/push_swap_visualizer/
⧪ the use of AI was helpful, it reduced the time needed for repetitive work, like adding the missing prototypes of functions to the header file and providing quick explanations or reminders for standard algorithm concepts.
